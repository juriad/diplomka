\chapter{Representations of Trees}

There are many ways to represent static ordinal trees in memory.
The traditional way, which most people know and use, is to have a structure for each vertex pointing to all its children and its parent, and sometimes storing an additional value.
Each edge of the tree is stored twice as a pointer of size $w$.
Even if we did not need any other space to manage the vertex structures, the space occupied by the edges takes $\Omega (n \log n)$ bits.

In our discussion we assume that no additional value is present, and we are therefore interested in the structure of the tree itself.
If it was, we could move it to an external table which is indexed by the number of the vertex to which it belongs.
The number of the vertex can be its general \rank{}, or if we store values only in leaves, it can be its \leafRank{}.
This transformation maintains the same space complexity.

We can express how many ordinal trees with $n$ vertices exist in total using Catalan numbers.
$$ | \mathcal{T}(n) | = C_{n-1} = \frac{1}{n} {2n - 2 \choose n - 1} $$
The $-1$ stems from the tree having a single root.
$$ \log | \mathcal{T}(n) | \sim \log \frac{1}{n}\frac{4^{n-1}}{\sqrt{(n-1)\pi}} = 2(n - 1) - \frac{1}{2} \log{(n - 1)\pi} - \log n \sim 2n - O(\log n) $$
When we design a succinct data structure for ordinal trees, we are limited by the space given by the leading term: $2n + o(n)$ bits.

In this and in the next chapter we show several succinct data structures which overcome the logarithmic factor introduced by using pointers, and get close to the optimum space complexity.
We start with defining operations which are desired to be supported by the tree data structures.
The rest of this chapter is then dedicated to simple representations which encode the whole tree in $\sim 2n$ bits and support various operations via additional indices, which we developed in the chapter \ref{c:bit-strings}.
More advanced structures which do not have the limitations of the simple structures are shown in the next chapter.

\section{Operations}

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{|L{0.7}|J{1.3}|}
		\hline
		$\mathit{op}(\mathit{arg}) \rightarrow \mathit{ret}$
		& Description \\ \hline \hline
		
		$\anyRank(i) \rightarrow r$, \newline
		$\anySelect(r) \rightarrow j$, \newline
		$\anyPrev(i) \rightarrow j$, \newline
		$\anyNext(i) \rightarrow j$, \newline
		$\anyFirst(i) \rightarrow j$, \newline
		$\anyLast(i) \rightarrow j$, \newline
		$\anySize() \rightarrow n$
		& These are general operations which can be grouped together since it is usually desired to support them all.
		The operations are defined for various parts of the tree, as it is shown in the following rows.
		
		All operations can be expressed using \anyRank{}, \anySelect{}, and \anySize, however those are not always available.
		Alternatively an iteration over objects is possible if \anyPrev{}, \anyNext{}, \anyFirst{}, \anyLast{} are defined.
		
		In all algorithms we assume that the bounds are checked before the operation commences.\\ \hline \hline
		
		$\preRank(i)$, $\preSelect(r)$, \newline
		$\postRank(i)$, $\postSelect(r)$, \newline
		$\inRank(i)$, $\inSelect(r)$, \newline
		$\dfudsRank(i)$, $\dfudsSelect(r)$, \newline
		$\loRank(i)$, $\loSelect(r)$
		& The \rank{} and \select{} operations come in several flavors based on method of the tree traversal and when the vertices are assigned their numbers.
		\begin{itemize*}
			\item Pre-order number is assigned when DFS visits a vertex from its parent;
			\item post-order when DFS leaves a vertex to its parent;
			\item in-order when DFS returns to a vertex from its child and leaves to another of its children;
			\item dfuds-order is assigned to all children when its parent is first visited;
			\item lo-order is assigned when BFS visits a vertex.
		\end{itemize*}\\ \hline
		
		$\childAny$ operations, \newline
		$\parent(i) \rightarrow j$, \newline
		$\isRoot(i) \rightarrow b$
		& \childSelect{} is provided also with the parent vertex as an additional argument.
		\childFirst{}, \childLast{} are defined for the parent vertex rather than their siblings.
		The operation \childSize{} is replaced by \degree{} which is defined for the parent vertex.
		\parent{} and \isRoot{} complete the set of the navigation operations.\\ \hline
	
		$\levelAny$ operations, \newline
		$\dep(i) \rightarrow l$
		& The level operations can be parametrized in two orthogonal ways:
		\begin{iteminline}
			\item the level (or range thereof) of the tree in which we are interested,
			\item and the subtree of a vertex to which the query is restricted.
		\end{iteminline} \\ \hline
		
		$\leafAny$ operations, \newline
		$\isLeaf(i) \rightarrow b$
		& The order respects the ranks of the leaves (pre-order for DFS, lo-order for BFS).
		The queries can be further restricted to levels and subtrees.\\ \hline \hline
		
		$\isAncestor(i_1, i_2) \rightarrow b$, \newline
		$\levelAncestor(i, d) \rightarrow j$, \newline
		$\lca(i_1, i_2) \rightarrow j$
		$\distance(i_1, i_2) \rightarrow n$
		& Ancestral operations are usually the hardest to support; they usually require specialized indices.
		The operation \lca{} stands for Lowest Common Ancestor. \\ \hline
		
		$\hei(i) \rightarrow l$, \newline
		$\deepestVertex(i) \rightarrow j$, \newline
		$\subtreeSize(i) \rightarrow n$
		& Some other operations which can be supported by tree data structures. \\ \hline
	\end{tabularx}
	\caption{List of operations defined for ordinal trees}
	\label{tab:list-ops}
\end{table}

The operations are defined in the table \ref{tab:list-ops}.
The desired running time of all operations is $O(1)$.

\emph{Navigation operations} are such operations which allow traversal of the tree.
The operations \childRank{}, \childSelect{} and \degree{} are preferred over the relative operations \childPrev{}, \childNext{}, \childFirst{} and \childLast{}.
In order to navigate up in the tree \parent{} and \isRoot{} are required.

In the definitions, we use $i$ and $j$ to refer to the internal representation of the vertex.
They are not meant to be used for anything else except for being passed to an operation as an argument.
If the number of the vertex matters, one of the supported ranking operations, which map the vertices into an interval $[0, n)$, shall be used.

\section{Representations}

An ordinal tree can be stored in a single bit string in several different ways.
Here we describe how it is possible to store a tree in a bit string of size $N = \sim 2n$ bits\footnote{
	We use $N$ to refer to size of the bit string, and $n$ to refer to number of vertices.
}.
\begin{description}
	\item[Level-Order Unary Degree Sequence (LOUDS)]
	LOUDS is the oldest representation with most limitations on supported operations, which it compensates by its simplicity as only \rank{} and \select{} operations are required.
	It stores the data in a heap-like way by levels, which results in subtrees being spread throughout the representation.
	The consequence of the storage is that it lacks all subtree-restricted and ancestral operations.
	
	\item[Balanced Parentheses (BP)]
	With \match{} and \enclose{} operations available on balanced bit strings, the BP representation was invented.
	It uses the natural mapping between ordinal trees and balanced bit strings.
	It supports many operations which were not possible before, however the price for it is that multiple indices are necessary.
	The \childRank{} and \childSelect{} operations are not supported natively.
	
	\item[Depth-First Unary Degree Sequence (DFUDS)]
	DFUDS representation is a hybrid representation of the previous ones using an alternative mapping to a balanced bit string.
	The navigation queries are fully supported while it retains the locality of the subtrees.
	
	Authors often compete and equip their DFUDS and BP structures with more indices that support operations with which the other representation comes.
\end{description}

\section{LOUDS}

The first method of representing an ordinal tree succinctly was first described by \cite{jacobson1989space}.
The encoding of the tree is based on BFS traversal.
The vertices report their degrees in unary system; we call it the \emph{degree sequence}
The representation is prefixed by \str{10}.

\begin{algorithmic}
\Function{\LOUDSRepresentation}{$R$}
	\State $Q \gets []; \enqueue(Q, R)$ \Comment{The queue is initialized with the root of the tree}
	\State $\out(\str{10})$
	\While{$V \gets \dequeue(Q)$}
		\ForAll{$C \gets \children(V)$}
			\State $\out(\str1)$
			\State $\enqueue(Q, C)$
		\EndFor
		\State $\out(\str0)$
	\EndWhile
\EndFunction
\end{algorithmic}

\begin{lemma}
	There are $n$ ones and $n+1$ zeros in the LOUDS representation of a tree with $n$ vertices.
\end{lemma}
\begin{proof}
	The \str{10} corresponds to an artifical supervertex which has a single child -- the root of the tree.
	Each vertex of the tree is a child of a vertex and therefore was accounted by a one in the degree sequence of its parent.
	The number of ones is therefore the same as the number of all vertices in the tree.
	Each vertex is responsible for its own zero, plus there is one extra zero for the supervertex.
	
	The whole bit string, which we call $S$ has $N = 2n + 1$ bits.
\end{proof}

As there is a one and a zero belonging to each vertex, we can associate the $i$-th vertex with the $i$-th one and the $(i+1)$-st zero.
Note that the one is actually in the degree sequence of the parent of $i$, and the zero is terminating its degree sequence.

We use the position of the associated one for the internal representation of a vertex.
Zeros-based structure is also possible. \cite{rahman2006engineering}

\subsection{Navigation Operations}

We equip the bit string $S$ storing the representation of the tree with \rank{} and \select{} indices.
Because of the correspondence between ones and zeros, we can easily change between them using the following two functions.
The extra function \toBeginning{} returns the position where the degree sequence starts.

\begin{algorithmic}
\Function{\toOnes}{$S, i$}
	\State \Return{$\select_1(S, \rank_0(S, i) - 1)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\toZeros}{$S, i$}
	\State \Return{$\select_0(S, \rank_1(S, i) + 1)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\toBeginning}{$S, i$}
	\State \Return{$\select_0(S, \rank_1(S, i)) + 1$}
\EndFunction
\end{algorithmic}

The vertex \inRank{} and \inSelect{} are simply $\rank_1(S, i)$ and $\select_1(S, r)$.
No other vertex orderings are supported.

The navigation operations are relatively easy.
We also define an optimized version of the operation \childLast since we will need it later.

\begin{algorithmic}
\Function{\isRoot}{$S, i$}
	\State \Return{$i = 0$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\isLeaf}{$S, i$}
	\State \Return{$\toZeros(S, i) = \toBeginning(S, i)$} \Comment{Degree sequence is empty}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\parent}{$S, i$}
	\State \Return{$\toOnes(S, \succ_0(S, i))$} \Comment{Conversion from zeros to ones}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\degree}{$S, i$}
	\State \Return{$\toZeros(S, i) - \toBeginning(S, i)$} \Comment{Length of its degree sequence}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\childRank}{$S, i$}
	\State \Return{$i - \pred_0(S, i)$} \Comment{Distance from the previous zero}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\childSelect}{$S, i, k$}
	\State \Return{$\toBeginning(S, i) + k - 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\childLast}{$S, i$} \Comment{\childFirst{} is merrily $\childSelect(S, i, 1)$}
	\State \Return{$\toZeros(S, i) - 1$}
\EndFunction
\end{algorithmic}

\bigbreak

The data structure can support more operation when augmented with more succinct indices.

\subsection{Depth and Level Queries}

We propose a new index for the LOUDS representation which allows to query depth of a vertex and indirectly supports all level queries (without restriction on subtree).
This was not possible before.

We define a bit string $D$ which contains $1$ at the position of level boundaries -- the terminal zero of the last vertex in each level, including the zero which belongs to the supervertex.
We also add the succinct \rank{} a \select{} indices for the bit string $D$; note that only \select$_1$ is required.
Using $D$ we can support \levelRank{}, \levelSelect{} (and thereby all \levelAny{} operations), and the operation \dep{}.

\begin{algorithmic}
\Function{\levelRank}{$S, i$}
	\State $z \gets \prev_1(D, i)$ \Comment{Terminal zero of the previous level}
	\State \Return{$\rank_1(S, i) - \rank_1(S, z)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\levelSelect}{$S, i, l$}
	\State $z \gets \select_1(D, l)$ \Comment{Terminal zero of the previous level}
	\State \Return{$\select_1(S, \rank_1(S, z) + i)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\levelSize}{$S, l$}
	\State $z \gets \select_1(D, l)$ \Comment{Terminal zero of the previous level}
	\State $z' \gets \select_1(D, l + 1)$ \Comment{Terminal zero of the next level}
	\State \Return{$\rank_1(S, z) - \rank_1(S, z')$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\dep}{$S, i$}
	\State \Return{$\rank_1(D, i)$}
\EndFunction
\end{algorithmic}

\subsubsection{Succinct Index for Depth}\label{ss:louds-depth}

The problem with storing boundaries of all levels is that there can be up to $O(n)$ levels in total, which leads to $O(N)$ bits even in case of an optimal FID.
We work around the problem by utilizing the fact that if there are many levels, they must be short.
They are in fact short enough to precompute the level boundaries in a look-up table.

We split the bit string $D$ into blocks of size $b = \frac{\log N}{2}$ and for each block we remember only the position of the first $1$, or lack thereof.
This table $D'$ requires $\frac{N}{b} \log b = O(\frac{N \log\log N}{\log N}) = o(N)$ bits.

\begin{lemma}
	We can restore any $b$ consecutive bits of the original bit string $D$ in constant time.
\end{lemma}
\begin{proof}
	If there is no one in the block $i$, there is also no level boundary and the block contains only zeros.
	If there is a $1$ and its position is equal to $2n$, then it marks the end of the last level; the rest of the block is filled with zeros.

	Otherwise, there is a $1$ at position $p$ and there must be a $1$ at position $q < p$ in the representation of the level, because it is not the last level.
	We find this vertex $q$ of the level using predecessor search on $S$ and find position $z$ of its zero; this is the end of the next level.
	If $z$ is outside of the block, we end.
	
	The whole level spanning over the interval $[p + 1, z]$ is contained within the block $i$.
	We can use a look-up table \blockOfD{} which we index by the block $i$ bits of $S$ and by the offsets of $p$ and $z$.
	The look-up table gives us all positions of ends of levels within the block $i$.
	Given the boundaries of a single level, the boundaries of the next level can be determined by counting the same number of zeros as there were ones in the previous level.
\end{proof}

\begin{algorithmic}
\Function{\blockOfD}{$S, i$} \Comment{$i$ is a block number}
	\State $p' \gets D'[i]$
	\If{$p' = -1$} \Comment{No $1$ in the block}
		\State \Return{$0$}
	\Else
		\State $p \gets i b + p'$
		\If{$p = 2n$} \Comment{The end of the last level}
			\State \Return{$1 \bitlsh (b - p' - 1)$} \Comment{$1$ at position $p'$}
		\Else
			\State $z \gets \toZeros(S, \pred_1(S, p))$
			\If{$z \ge (i + 1) b $} \Comment{The level ends outsize of the block $i$}
				\State \Return{$1 \bitlsh (b - p' - 1)$}
			\Else
				\State \Return{$\blockOfD[S[i b : (i + 1) b], p', z \% b]$}
			\EndIf
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}

\subsection{\label{ss:leaf-queries}Leaf Operation}

Tree data structures often allow a direct iteration of its leaves.
Although the usual order of leafs corresponds to DFS traversal, LOUDS supports an access to the leaves in level-order in accordance with the its only ranking operation -- \inRank{}.
We also parametrize the operations by the desired depth of the leaves -- upper and lower bounds $u \le l$.

\begin{lemma}
	Whenever there are two consecutive zeros in LOUDS representation, the latter one is associated with a leaf.
\end{lemma}
\begin{proof}
	There is always a zero immediately preceding the representation of every vertex.
	A leaf is a vertex with its degree equal to zero; the degree sequence consists of only a single zero.
	A leaf can therefore be localized by looking for two consecutive zeros; this gives us its zeros-based number.
\end{proof}

The original idea for this index comes from \cite{munro1998space}.
We have seen a solution to a similar problem in \ref{ss:index-without-data}.

We derive a bit string $L$ and build \rank{} and \select{} indices for it.
$$L = \bitnot S \bitand \bitnot (S \bitrsh 1)$$

All the functions require a correction by one if the first vertex of the level $l$ is a leaf.

\begin{algorithmic}
\Function{\leafSize}{$S, l, u$}
	\State $f \gets \levelFirst(S, l)$ \Comment{First vertex in the range}
	\State $f_0 \gets \toZeros(S, f)$
	\State $z_0 \gets \toZeros(S, \levelLast(S, u))$
	\State \Return $\rank_1(L, z_0) - \rank_1(L, f_0) + \isLeaf(S, f)$
\EndFunction
\end{algorithmic}

\begin{algorithmic}	
\Function{\leafRank}{$S, l, i$} \Comment{We assume $i$ is a leaf at the admissible level}
	\State $f \gets \levelFirst(S, l)$ \Comment{First vertex in the range}
	\State $f_0 \gets \toZeros(S, f)$
	\State \Return{$\rank_1(L, \toZeros(i)) - \rank_1(L, f_0) + \isLeaf(S, f)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\leafSelect}{$S, l, i$}
	\State $f \gets \levelFirst(S, l)$ \Comment{First vertex in the range}
	\State $f_0 \gets \toZeros(S, f)$
	\State $o \gets \rank_1(L, f_0) - \isLeaf(S, f)$ \Comment{Offset}
	\State \Return{$\toOnes(S, \select_1(L, o + i))$}
\EndFunction
\end{algorithmic}

\subsection{Final Thoughts}

The main problem of this representation appears to stem for the non-locality of the near vertices.
The unsupported operations are more concerned about ancestors and subtrees than siblings and levels.
We developed a new index for the operation \dep{} and \levelAny{} which greatly expands the possibilities.
Its simple implementation requiring only three types of indices (\rank{}, \select{}, \blockOfD{}) make it suitable for cases when there are not many requirements set on the supported operations.

\section{BP}

In the previous section, we have seen that it is possible to build a succinct data structure for storing trees which requires essentially only the \rank{} and \select{} operations on the underlying bit string.
Here we focus on a different schema which exploits the property that the two symbols associated with a vertex are correctly matched in the bit string.
We represent them as parentheses in a balanced bit string, for which we utilize the \match{} and \enclose{} operations which we developed earlier in \ref{s:match-enclose}.

The representation is based on Depth-First Search and follows two rules:
\begin{enumerate}
	\item When a vertex is entered from its parent, the vertex is \emph{opened} and an opening parenthesis is outputted in the representation.
	\item When a vertex is left to its parent, the vertex is \emph{closed} and a closing parenthesis is outputted.
\end{enumerate}
Although the root vertex does not have a parent, it is opened and closed as if it had one.

\begin{algorithmic}
\Function{\BPRepresentation}{$R$}
	\State $S \gets []; \push(S, R)$ \Comment{The stack is initialized with the root of the tree}
	\While{$V \gets \pop(S)$}
		\If{$V.\state = \UNSEEN$} \Comment{We came from its parent}
			\State $\push(S, V)$ \Comment{We return $V$ to the stack}
			\State $V.\state \gets \OPEN$
			\State $\out(\openingParen)$
			\ForAll{$C \in \reverse(\children(V))$}
				\State $\push(S, C)$
			\EndFor
		\ElsIf{$V.\state = \OPEN$} \Comment{All children has been processed}
			\State $V.\state \gets \CLOSED$
			\State $\out(\closingParen)$
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}

An alternative definition of this schema can be expressed recursively:
\begin{enumerate}
	\item A leaf is encoded with a pair of parentheses.
	\item An inner vertex is encoded as a concatenated string of encodings of its children enclosed by a pair of parentheses.
\end{enumerate}
We can see from this definition that each subtree occupies a continuous substring.

\bigbreak

We associate each vertex with its opening parenthesis.
By using the operation \match we can easily switch between these two.

The operations \preRank, \preSelect, \postRank, and \postSelect are immediately supported by opening-based and closing-based \rank{}s and \select{}s on the underlying bit string $S$.
We first show implementation of the operations which do not need any auxiliary index and can be expressed using only the primitives provided by $S$.

\begin{algorithmic}
\Function{\isRoot}{$S, i$}
	\State \Return{$i = 0$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\isLeaf}{$S, i$}
	\State \Return{$S[i + 1] = \closingParen$} \Comment{Is the parenthesis immediately closed?}
\EndFunction
\end{algorithmic}

\subsubsection{Basic Navigation Queries}

\begin{algorithmic}
\Function{parent}{$S, i$}
	\State \Return{$\enclose(S, i)$}
\EndFunction
\end{algorithmic}

Neither \degree{} nor \childRank{} nor \childSelect{} are available without an additional index; we therefore resort to the direct implementation of the rest of the \childAny{} operations:

\begin{algorithmic}
\Function{\childFirst}{$S, i$}
	\State \Return{$i + 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\childLast}{$S, i$}
	\State \Return{$\findClose(S, i) - 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\childNext}{$S, i$}
	\State \Return{$\findClose(S, i) + 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\childPrev}{$S, i$}
	\State \Return{$\findOpen(S, i - 1)$}
\EndFunction
\end{algorithmic}

\subsubsection{Other Native Operation}

The following natively supported operations use the property that a subtree of $v$ is fully contained in the representation of $v$.

\begin{algorithmic}
\Function{\dep}{$i$}
	\State \Return{$\parenDepth(i)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\isAncestor}{$i_1, i_2$}
	\State \Return{$i_1 \le i_2 \booland \findClose(i_1) \ge i_2$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\subtreeSize}{$i$}
	\State \Return{$\rank_1(\findClose(i)) - \rank_1(i) + 1$}
\EndFunction
\end{algorithmic}

The group of operations consisting of \lca, \distance, \deepestVertex, and \hei can be solved by minimum or maximum range queries.

\begin{algorithmic}
\Function{\lca}{$i_1, i_2$}
	\If{$\isAncestor(i_1, i_2)$}
		\State \Return{$i_1$}
	\ElsIf{$\isAncestor(i_2, i_1)$}
		\State \Return{$i_2$}
	\Else
		\State \Return{$\enclose(i_1, i_2)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\distance}{$i_1, i_2$}
	\State $a \gets \lca(i_1, i_2)$
	\State \Return{$\dep(i_1) + \dep(i_2) - 2 \dep(a)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\deepestVertex}{$i$}
	\State \Return{$\RMQi(i, \match(i))$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{\hei}{$i$}
	\State \Return{$\dep(\deepestVertex(i)) - \dep(i)$}
\EndFunction
\end{algorithmic}

\subsubsection{In-Order Rank and Select and Leaf Operations}



\todo{in-order}

	We showed the technique in \ref{ss:leaf-queries} where we were looking for the pattern $0\underline{0}$, whereas for BP it would be $\underline{(})$.

\subsubsection{Final Thoughts}

Various indices were proposed to extend the set of supported operations beyond what we have shown.
\todo{Refs: Balanced Parentheses Strike Back}
\begin{itemize}
	\item index support for $child\_rank$ and $child\_select$;
	\item index support for $level\_ancestor$;
\end{itemize}

\section{DFUDS}

\emph{Depth-First Unary Degree Sequence} is a hybrid encoding with advantages from both LOUDS (child queries are natively supported) and BP (each subtree is stored locally instead of being spread throughout the encoding).
The encoding is defined recursively:
A leaf is encoded as a closing parenthesis.
An inner vertex is encoded as a $degree$ opening parentheses followed by a single closing parenthesis and concatenated encoding of its children.
For convenience, one opening parenthesis is prepended to make the sequence of parentheses balanced.

\todo{formalize queue}

\begin{algorithmic}
\Function{construct}{$R$}
	\State $S \gets \{R\}$ \Comment{The stack is initialized with the root of the tree}
	\State $write("(")$
	\While{$V \gets S$}
%		\If{$V.state = UNSEEN$} \Comment{We came from its parent}
%			\State $V.state \gets OPEN$
%			\State $S \gets \{V\}$ \Comment{We return to $V$ after all its children}
			\ForAll{$C \gets children(V)$}
				\State $write("(")$
			\EndFor
			\State $ S \gets children(V)$
			\State $write(")")$
%		\ElsIf{$V.state = OPEN$} \Comment{All children has been processed}
%			\State $V.state \gets CLOSED$
%		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}

\begin{lemma}
	This encoding gives indeed a balanced string of parentheses.
\end{lemma}
\begin{proof}
	Each subtree lacks one opening parenthesis at the beginning to be correctly matched string of parentheses.
	
	The proof goes by induction.
	The claim holds for a leaf, which is only a closing parenthesis, which misses its matching opening one.
	
	We assume, that the claim holds for all $degree$ subtrees $T_1, \ldots, T_d$ of vertex $v$.
	Vertex $v$ contains $degree$ opening and one closing parenthesis.
	The closing one matches the last opening one, leaving $degree - 1$ of be matched with the excessive ones in the subtrees.
	$T_1, \ldots, T_{d-1}$ gets matched, leaving one closing parenthesis in $T_d$ unmatched, which is the one that the claim requires.
	
	The only unmatched parenthesis is matched in the end with the artificially prepended one.
\end{proof}

\subsection{Basic Navigation Queries}

We associate each vertex with the first symbol of its representation.
Then it is easy to test whether a vertex is a leaf or not.

\begin{algorithmic}
\Function{is\_root}{$i$}
	\State \Return{$i = 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_leaf}{$i$}
	\State \Return{$S[i] = ')'$} \Comment{Is the parenthesis a closing one?}
\EndFunction
\end{algorithmic}

For the following operation, the crucial observations are:
\begin{enumerate}
	\item The opening parentheses in the degree sequence matches the closing parentheses immediately preceding a child representation.
	\item In a subtree of a vertex $v$, the last closing parenthesis, which represents the last leaf, matches a parenthesis in a degree sequence of $v$'s parent.
\end{enumerate}

We first define a helper functions which navigate from any position in vertex representation to its beginning (which is the symbol associated with the vertex) and to its end (which is always a closing parenthesis).

\begin{algorithmic}
\Function{to\_beginning}{$p$}
	\If{$p = 0$}
		\State \Return{$-1$} \Comment{The representation of root starts at position 1}
	\ElsIf{$prev_)(p) < 0$}
		\State \Return{$1$} \Comment{Correction for the root}
	\Else
		\State \Return{$prev_)(p) + 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{to\_end}{$p$}
	\If{$p = 0$}
		\State \Return{$-1$}
	\Else
		\State \Return{$succ_)(p)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{to\_last}{$p$} \Comment{Navigates to the end of the subtree representation}
	\If{$is\_leaf(i)$}
		\State \Return{$p$}
	\Else
		\State \Return{$find\_close(enclose(to\_beginning(p)))$}
	\EndIf
\EndFunction
\end{algorithmic}

Using these function we can support pre-order rank and select queries.
Post-order operations are not supported.

\begin{algorithmic}
\Function{pre\_rank}{$i$}
	\State \Return{$rank_)(to_end(i))$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{pre\_select}{$i$}
	\State \Return{$to\_beginning(select_)(i))$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{parent}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State $p \gets find\_open(i - 1)$ \Comment{Inside parent's degree sequence}
		\State \Return{$to\_beginning(p)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{degree}{$i$}
	\State \Return{$to\_end(i) - i$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_rank}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State $p \gets find\_open(i - 1)$
		\State \Return{$to\_end(p) - p$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_select}{$i, n$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State $p \gets to\_end(i) - n$
		\State \Return{$find\_close(p) + 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\subsection{Other operations}

\begin{algorithmic}
\Function{is\_ancestor}{$i, j$}
	\If{$is\_leaf(i)$}
		\State \Return{$i = j$}
	\Else
		\State \Return{$j \ge i \booland j \le to\_last(i)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{subtree\_size}{$i$}
	\If{$is\_leaf(i)$}
		\State \Return{$1$}
	\Else
		\State \Return{$rank_)(to\_last(i)) - rank_)(i)$}
	\EndIf
\EndFunction
\end{algorithmic}

\subsubsection{Lowest Common Ancestor}

The operation LCA works similarly as in BP, however it needs to be shown that it works.
Let's assume that neither $i_1$ nor $i_2$ is ancestor of the other one; the $min(i_1, i_2)$ the answer.
We further assume that $i_1 < i_2$ and that the lowest common ancestor is $j = lca(i_1, i_2)$.
The vertex $j$ is left from both $i_1, i_2$ because it is assigned lower pre-order number than any of its descendants.
We again (as in section \ref{ss:enclose2}) call $p_1 < p_2$ the distinct children of $j$ which contain $i_1$ and $i_2$.

We look at excess values of children of $j$.
Each child and its subtree forms a sequence of matching parenthesis with the exception of the last one, which is a closing parenthesis.
From this follows that $rmqi(i, to\_last(i)) = to\_last(i)$.

We look into the properties of $rmqi(i_1, i_2 - 1)$.
Every child, whose ending parenthesis is contained in the range sets a new minimum.
The subtree of $p_2$ could cause a problem, that it would contain the position of the minimum.
It cannot be the last parenthesis of $p_2$, because we end the interval just before it.
It also will not be any other parenthesis $p \ge p_2$ because $excess(p) \ge excess(to_last(p_2)) + 1 = excess(to\_last(child\_prev(p_2)))$.
In case of equality, the $rmqi$ returns the left-most occurrence of the minimum.

The $rmqi(i_1, i_2 - 1)$ returns position of the last parenthesis of the previous sibling of $p_2$ and therefore $p_2 = rmqi(i_1, i_2 - 1) + 1$.
The result is then $lca(i_1, i_2) = j = parent(p_2)$.

\begin{algorithmic}
\Function{lca}{$i_1, i_2$}
	\If{$is\_ancestor(i_1, i_2)$}
		\State \Return{$i_1$}
	\ElsIf{$is\_ancestor(i_2, i_1)$}
		\State \Return{$i_2$}
	\Else
		\State $p_2 \gets rmqi(i_1, i_2 - 1) + 1$
		\State \Return{$parent(p_2)$}
	\EndIf
\EndFunction
\end{algorithmic}

\bigskip

Various indices were proposed to extend the set of supported operations beyond what we have shown.
\todo{Refs: Ultra-succinct representation of ordered trees}
\begin{itemize}
	\item index support for $depth$, which makes possible to query $distance$ between vertices;
	\item index support for $level\_ancestor$;
	\item index support for querying leaves in a subtree.
	This again uses local properties of detecting leaves.
	We would be looking for the second of two consecutive closing parentheses $)\underline{)}$.
	Note that in case when the tree root is a leaf, this does not work, however this special case is easy to handle.
\end{itemize}

\subsection{Comparison of BP and DFUDS}

BP is the easiest way to encode a tree in an array of $2n$ bits.
Its main advantage is the simplicity and once natural support of $depth$ queries, for which it pays by hard $child\_rank$, $child\_select$ and $degree$ operations.

DFUDS is the opposite of BP: it is less intuitive, it supports all the basic navigation queries, however it lacks an easy support for $depth$ queries.

It turns out that $lca$ is supported by both representations in a very similar way, which can be surprising.
There are indices which add support for the operations which are native for the other structure, however they tend to be rather theoretically interesting than useful in practice. \todo{ref}

It is not possible to say that one is better than the other one; it always depends on their usage.
For example, if we restrict degrees of the vertices to be constant, BP representation is suddenly a very good choice.
Similarly, the restriction of height of the tree causes DFUDS to overcome the lack of native $depth$ operation by a brute force implementation.