\chapter{Representations of Trees}

There are many ways to represent trees in memory.
The traditional approach is to have a structure for each vertex pointing to all its children and its parent, and sometimes storing an additional value.
In our discussion we can assume that no additional value is present; if it was, we could move it to an external table and reference it by a pointer while maintaining the same space complexity.
We are therefore interested in representation only of the structure of the tree.

We can express how many such trees with $n$ vertices exist in total using Catalan numbers.
$$ | \mathcal{T}(n) | = C_{n-1} = \frac{1}{n} {2n - 2 \choose n - 1} $$
The $-1$ stems from the tree having a single root.
$$ \log | \mathcal{T}(n) | \sim \log \frac{1}{n}\frac{4^{n-1}}{\sqrt{(n-1)\pi}} = 2(n-1) - \frac{1}{2} \log{(n - 1)\pi} - \log n \sim 2n - O(\log n) $$
When we design a succinct data structure for ordinal trees, we are limited by the space given by the leading term: $2n + o(n)$ bits.

In the traditional data structures, each edge of the tree is stored twice as a pointer of size $w$.
Even if we did not need any other space to manage the vertex structures, the space occupied by the edges takes $\Omega (n \log n)$.

In this and in the next chapter we show several succinct data structures which overcome the logarithmic factor introduced by using pointers and get close to the optimum space complexity.
We start with defining operations which we want to be able to be supported on the succinct structures.
Then we define the distinct ways how to encode a tree in a single bit string of size $2n$ bits and support various operations using usually only the primitive operations which we developed in the chapter \ref{c:bit-strings}.

\section{Operations}

We define operations which we discuss in context of tree data structures.

\todo{rank and select are counted from 1, sort of}

\noindent\begin{tabularx}{\textwidth}{|L{0.7}|L{1.3}|}
	\hline
	$op(arg) \rightarrow ret$
	& Description \\ \hline \hline
	
	$*\_rank(i) \rightarrow n$, \newline
	$*\_select(n) \rightarrow j$, \newline
	$*\_prev(i) \rightarrow j$, \newline
	$*\_next(i) \rightarrow j$, \newline
	$*\_first(i) \rightarrow j$, \newline
	$*\_last(i) \rightarrow j$, \newline
	$*\_size() \rightarrow n$
	& These are general operations which we may want to support on various parts of the tree.
	All operations can be expressed using rank, select, and size, however those are not always available. \\ \hline \hline
	
	$\{pre,post,in,lo\}\_*$ operations
	& The rank and select operations come in four flavors based on method of the tree traversal and when the vertex is assigned its number:
	pre-order, in-order, post-order in case of DFS, and level-order in case of BFS. \\ \hline
	
	$child\_*$ operations, \newline
	$parent(i) \rightarrow j$, \newline
	$is\_root(i) \rightarrow b$
	& The operation $child\_select$ needs an additional argument -- the parent vertex.
	The operations $child\_first$, $child\_last$ can be take parent vertex as an argument instead of the sibling.
	We add the operations $parent$ and $is\_root$ to this category to allow basic navigation queries.
	The operation $child\_size$ is usually called $degree$ and takes the parent vertex as an argument.\\ \hline

	$level\_*$ operations, \newline
	$depth(i) \rightarrow l$
	& The level operations can be parametrized in two orthogonal ways:
	the level of the tree which we are interested in (or range thereof), and subtree of the tree we are restricted the queries to. \\ \hline
	
	$leaf\_*$ operations, \newline
	$is\_leaf(i) \rightarrow b$
	& Operations on the set of leaves in the tree.
	The rank should be monotonous in respect to the vertex rank. 
	Again, the queries can be restricted to levels and subtrees.\\ \hline \hline
	
	$is\_ancestor(i, j) \rightarrow b$, \newline
	$level\_ancestor(i, d) \rightarrow j$, \newline
	$lca(i_1, i_2) \rightarrow j$
	$distance(i_1, i_2) \rightarrow n$
	& The operation $lca$ stands for Lowest Common Ancestor.
	Ancestral operations are usually hard to support and require specialized indices. \\ \hline
	
	$height(i) \rightarrow l$, \newline
	$deepest\_vertex(i) \rightarrow j$, \newline
	$subtree\_size(i) \rightarrow n$
	& Other possible operations which could be supported by the data structure. \\ \hline
\end{tabularx}

In the queries we use $i$ and $j$ to refer to the internal representation of the vertex.
Although it often is the same as position of a specific symbol related to the vertex in the representation, for the user of the structure it is an atomic value with no meaning other than a reference which can be used for querying the structure.
If the number of the vertex matters, the user is advised to use one of the ranking operations which map the vertices into an interval $[0, n-1]$.
This can be necessary if we want to interact with other structures, such as addressing the value of the vertex stored in an external table.

\section{Representations}

A tree can be stored as a single bit string in several different ways.
Here we describe how it is possible to store a tree in a bit string of size $\sim 2n$ bits.
\begin{enumerate}
	\item Level-Order Unary Degree Sequence -- a heap-like structure which supports the basic navigation queries requiring only rank and select.
	\item Balanced Parentheses -- uses the natural mapping between ordinal trees and matching parentheses.
	\item Depth-First Unary Degree Sequence -- combination of the previous two approaches offering an alternative mapping to matching parentheses.
\end{enumerate}

LOUDS is the oldest representation with most limitations on supported operations, which it compensates by its simplicity.
The biggest limitation are subtree-restricted queries and ancestor queries because of storage of the vertices by levels, which causes each subtree to be spread in the representation.

With match and enclose operations available on parentheses, the BP representation was invented.
It supports the queries which were not possible before, however it pays for it by using multiple indices, which are necessary even for simple child queries.
DFUDS representation is a hybrid representation, which takes the better parts of both previous ones.
The navigation queries are fully supported while it retains the locality of subtrees.
Authors often compete and equip their DFUDS or BP structures with more indices that support operations with which the other representation comes.

\section{LOUDS}

The first method of storing an ordinal tree succinctly was first described by Jacobson in \todo{article}.
The encoding of the tree is based on its vertices reporting their degrees in unary system.
Vertices are processed in by levels; the representation is prefixed by \verb|10|:

\todo{Operations on Deque}

\begin{algorithmic}
\Function{construct}{$R$}
	\State $Q \gets \{R\}$ \Comment{The queue is initialized with the root of the tree}
	\State $write("10")$
	\While{$V \gets Q$}
		\ForAll{$C \gets children(V)$}
			\State $write("1")$
			\State $Q \gets \{C\}$
		\EndFor
		\State $write("0")$
	\EndWhile
\EndFunction
\end{algorithmic}

\begin{lemma}
	In a LOUDS representation of a tree with $n$ vertices, there are $n$ ones and $n+1$ zeros.
	Such encoding is succinct.
\end{lemma}
\begin{proof}
	The \verb|10| corresponds to an artifical supervertex which has a single child -- the root of the tree.
	Each vertex of the tree is a child of some vertex and therefore was accounted in the parent's degree.
	For each vertex, there is a one in its parent's representation.
	The number of ones is the same as the number of vertices in the tree.
	Each vertex is responsible for its own zero, plus there is a zero in the supervertex representation.
	
	As there are $2n+1$ bits in total, the representation is succinct.
\end{proof}

As there is a one and a zero belonging to each vertex, we can represent the $i$-th vertex by $i$-th one and $(i+1)$-th zero.
It could be more convenient to represent the supervertex with only \verb|1| instead of \verb|10|.
That way the operations would become clearer and off by one errors would not be an issue.
However we follow the representation as it was originally proposed.

\subsection{Basic Navigation Queries}

In order to support basic navigation queries in this representation, we add rank and select indices to turn it into a FID.
We formulate all the operations in terms of one-based numbering of vertices.
Zero-based implementation are also possible \todo{ref} and it even can compete the other representations.
\todo{Engineering the LOUDS representation}
Because of the correspondence between ones and zeros, we can easily change between them.

\begin{algorithmic}
\Function{to\_ones}{$i$}
	\State \Return{$select_1(rank_0(i) - 1)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{to\_zeros}{$i$}
	\State \Return{$select_0(rank_1(i) + 1)$}
\EndFunction
\end{algorithmic}

The level-order rank and select operations are one-based rank and select on the underlying bit string.

We know that the one of vertex is within the representation of its parent and the zero ends the list of ones belonging to its children.
Support of the queries is easy:

\begin{algorithmic}
\Function{is\_root}{$i$}
	\State \Return{$i = 0$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_leaf}{$i$}
	\State \Return{$select_0(rank_1(i)) + 1 = 0$} \Comment{Is there the first child?}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{parent}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$select_1(rank_0(i))$} \Comment{Conversion from zeros to ones; off by one}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{degree}{$i$}
	\State $next_0 \gets select_0(rank_1(i) + 1)$ \Comment{The zero within the vertex representation}
	\State $prev_0 \gets select_0(rank_1(i))$ \Comment{The zero within the previous vertex rep.}
	\State \Return{$next_0 - prev_0 - 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_select}{$i, k$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\ElsIf{$k \ge degree(i)$}
		\State \Return{$-1$}
	\Else
		\State $first \gets select_0(rank_1(i))$ \Comment{Preceding zero}
		\State \Return{$first + k$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_last}{$i$} \Comment{\textsc{child\_first} is merrily $child\_select(i, 1)$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State $zero \gets select_0(rank_1(i) + 1)$ \Comment{Terminal zero}
		\State \Return{$zero - 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_rank}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State $first \gets select_0(rank_0(i)) + 1$ \Comment{The left-most sibling}
		\State \Return{$i - first$}
	\EndIf
\EndFunction
\end{algorithmic}

\bigskip

We show how we can support more types of queries by augmenting the data structure with sublinear indices.
In our case, we use auxiliary bit strings and on top of them we build the ranking and selecting structures which we already know from FIDs.

\subsection{Depth and Level Queries}

We propose a new index for LOUDS representation which allows to query depth of a vertex and supports all level queries without restriction on subtree.
As far as we know, this index has not been described before.

If we knew where the boundaries of a level are in the bit string, stored also in a bit string, then a simple rank operation would give us the depth.
The problem with storing boundaries of all levels is that there can be up to $O(n)$ levels in total.
We work around the problem by utilizing the fact that if there are many levels, then these levels must be short.
They are in fact short enough for us to precompute the level boundaries in a look-up table.

We define a bit string $D$ which contains $1$ at the position of the terminal zero of the last vertex in a level, including the zero which belongs to the supervertex.
Using $D$ we can support $level\_rank$, $level\_select$ (and thereby all general $level\_*$) and $depth$ operations.

\begin{algorithmic}
\Function{level\_rank}{$i$}
	\State $prev_0 \gets prev_1(D, i)$ \Comment{Terminal zero of the previous level}
	\State \Return{$rank_1(S, i) - rank_1(S, prev_0)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{level\_select}{$i, l$}
	\State $prev_0 \gets select_1(D, l)$ \Comment{Terminal zero of the previous level}
	\State \Return{$select_1(S, rank_1(S, prev_0) + l)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{level\_size}{$l$}
	\State $prev_0 \gets select_1(D, l)$ \Comment{Terminal zero of the previous level}
	\State $next_0 \gets select_1(D, l + 1)$ \Comment{Terminal zero of the next level}
	\State \Return{$rank_1(S,  next_0) - rank_1(S, prev_0)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{depth}{$i$}
	\State \Return{$rank_1(D, i)$}
\EndFunction
\end{algorithmic}

\subsection{Succinct Index for Depth}

How to represent $D$ in $o(n)$ memory in order to keep the structure succinct?
We split this string $D$ into blocks of size $b = \frac{\log 2n}{2}$ and for each block we remember only the position of the first $1$, or lack thereof.
This table $D'$ requires $\frac{2n}{b} \log b = O(\frac{n \log\log n}{\log n}) = o(n)$ bits.

We now show how to restore any $b$ consecutive bits of the original bit string $D$ in constant time.
If there is no $1$ in a block, there is also no level boundary and such block is all zeros.
If there is a $1$ and its position is equal to $2n$, then it is the end of the last level and the block contains only this one $1$.

Otherwise, there is $1$ at position $p$ and there must be a $1$ in the representation of the level, because it is not the last one.
We find this last inner vertex of the layer using predecessor search on $S$ and find position $z$ of its zero; this is the end of the next level.
If $z$ is outside of the block, we end.

The whole level spanning $S[p+1, z]$ is contained within the block.
Now we can use a look-up table which we index by the part of $S$ which belongs to the block $b$ and by offsets of $p$ and $z$.
The look-up table gives us all positions of ends of levels within the block.
Such table merrily captures the repeated computation of finding last inner vertex on a level and turning it into zero-based number.

\begin{algorithmic}
\Function{block\_of\_D}{$i$}
	\State $p' \gets D'[i]$
	\If{$p' = -1$} \Comment{No $1$ in block}
		\State \Return{$0^b$}
	\Else
		\State $p \gets i b + p'$
		\If{$p = 2n$} \Comment{End of the last level}
			\State \Return{$0^b \bitor (1 \bitlsh (b - p' - 1))$} \Comment{$1$ at position $p'$}
		\Else
			\State $z \gets to\_zeros(pred_1(S, p))$
			\If{$z \ge (i+1) b $} \Comment{Level ends outsize block $b$}
				\State \Return{$0^b \bitor (1 \bitlsh (b - p' - 1))$}
			\Else
				\State \Return{$table[S[i b:(i+1)b], p', z - i b]$}
			\EndIf
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}

\subsection{\label{ss:leaf-queries}Leaf Queries}

Tree data structures often allows traversal of leaves in left to right fashion.
This seems to be impossible to support in our LOUDS representation.
Instead, we support enumeration of leaves and access to leaves in BFS order.
Although we defined the operations in sheer generality to be performed on a subtree of the tree, we allow no such restriction here.
When incorporate the depth index, we can parametrize the operations by depth of the leaves -- a pair of minimum and maximum depth: $dp = (min, max): min \le max$; either value can be left unbounded.

\begin{lemma}
	Whenever there are two consecutive zeros in LOUDS representation, the latter one is associated with a leaf.
\end{lemma}
\begin{proof}
	There is always a zero immediately preceding the representation of every vertex.
	A leaf is a vertex with degree equal to zero; LOUDS representation of such vertex is only a single zero.
	A leaf can therefore be localized by looking for two consecutive zeros; this gives us its zero-based number.
\end{proof}

We have seen a solution to a similar problem in \ref{ss:index-without-data}.
Here the formula for the derived bit string is:
$$L = \bitnot S \bitand \bitnot (S \bitrsh 1)$$
As we have already mentioned, we build rank and select indices on top of this calculated bit string $L$.

\begin{algorithmic}
\Function{leaf\_size}{$dp$}
	\State $first \gets level\_first(dp.min)$ \Comment{First vertex matching $dp$}
	\State $first_0 \gets to\_zeros(first)$
	\State $last_0 \gets to\_zeros(level\_last(dp.max))$
	\State \Return $rank_1(L, last_0) - rank_1(L, first_0) + is\_leaf(first)$
\EndFunction
\end{algorithmic}

\begin{algorithmic}	
\Function{leaf\_rank}{$dp, i$}
	\If{$depth(i)\ not\ within \ dp$}
		\State \Return{$-1$}
	\ElsIf{$not\ is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State $first_0 \gets to\_zeros(level\_first(dp.min))$
		\State $rank_1(L, to\_zeros(i)) - rank_1(L, first_0)$
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{leaf\_select}{$dp, n$}
	\If{$n \ge leaf\_size(dp)$}
		\State \Return{$-1$}
	\Else
		\State $first_0 \gets to\_zeros(level\_first(dp.min))$
		\State $offset \gets rank_1(L, first_0)$
		\State \Return{$to\_ones(select_1(L, n + offset))$}
	\EndIf
\EndFunction
\end{algorithmic}

\bigskip

The main problem of this representation appears to lay in non-locality of the data.
We often want to work in limited subtrees, which in this representation are spread throughout the bit string.
On he other hand its easy implementation requiring only two types of indices make it suitable for cases when we don't pose many requirements on the supported operations.

\section{BP}

In the previous section, we have seen that it is possible to build a succinct data structure for storing trees which requires only rank and select queries from the underlying bit string.
Here we focus on a different schema which exploits the property that the two symbols associated with a vertex are correctly matched in the bit string, for which we utilize the match and enclose operations which we developed earlier in \ref{s:op-bp}.

The representation is based on Depth-First Search and follows two rules:
\begin{enumerate}
	\item When we enter a vertex from its parent, we \emph{open} it, which is denoted in the representation by an opening parenthesis.
	\item When we leave a vertex to its parent, we \emph{close} it, which is denoted by a closing parenthesis.
\end{enumerate}
Although the root vertex does not have a parent, we open and close it as if it had one.

\begin{algorithmic}
\Function{construct}{$R$}
	\State $S \gets \{R\}$ \Comment{The stack is initialized with the root of the tree}
	\While{$V \gets S$}
		\If{$V.state = UNSEEN$} \Comment{We came from its parent}
			\State $ S \gets \{V\}$ \Comment{We return to $V$ after all its children}
			\State $V.state \gets OPEN$
			\State $write("(")$
			\State $ S \gets children(V)$
		\ElsIf{$V.state = OPEN$} \Comment{All children has been processed}
			\State $V.state \gets CLOSED$
			\State $write(")")$
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}

An alternative definition of this schema can be expressed recursively:
\begin{enumerate}
	\item A leaf is encoded with a pair of parentheses.
	\item An inner vertex is encoded as a concatenated list of encodings of its children enclosed by a pair of parentheses.
\end{enumerate}
From this definition, we can see that each subtree occupies a continuous substring.

\bigskip

We associate each vertex with its opening parenthesis; because of the symmetry in comparison to LOUDS representation, there is no reason to choose opening or closing parentheses over the others.
By using the operation $match$ we can easily switch between these two.

We can immediately support pre-order and post-order ranks and selects as opening-based and closing-based ranks and selects on the underlying bit string $S$.
We show implementation of the operations which do not need any auxiliary index and can be expressed using only the primitives provided by $S$.

\todo{Use \textbackslash{}mathit pretty much everywhere}

\begin{algorithmic}
\Function{is\_root}{$i$}
	\State \Return{$i = 0$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_leaf}{$i$}
	\State \Return{$S[i+1] = ')'$} \Comment{Is the parenthesis immediately closed?}
\EndFunction
\end{algorithmic}

\subsubsection{Basic Navigation Queries}

\begin{algorithmic}
\Function{parent}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$enclose(i)$}
	\EndIf
\EndFunction
\end{algorithmic}

Neither $degree$ nor $child\_rank$ nor $child\_select$ is possible to support without an additional index; we therefore resort to implementation of the rest of the $child\_*$ operations:

\begin{algorithmic}
\Function{child\_first}{$i$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$i+1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_last}{$i$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$find\_close(i) - 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_next}{$i$}
	\State {$n = find\_close(i) + 1$}
	\If{$S[n] = ')'$}
		\State \Return{$-1$}
	\Else
		\State \Return{$n$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_prev}{$i$}
	\If{$S[i - 1] = '('$}
		\State \Return{$-1$}
	\Else
		\State \Return{$find\_open(i - 1)$}
	\EndIf
\EndFunction
\end{algorithmic}

\subsubsection{Other Operation}

Other natively supported operations use the property that a subtree of $v$ is fully contained in the representation of $v$.

\begin{algorithmic}
\Function{depth}{$i$}
	\State \Return{$paren\_depth(i)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_ancestor}{$i, j$}
	\State \Return{$i \le j \booland find\_close(i) \ge j$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{subtree\_size}{$i$}
	\State \Return{$rank_1(find\_close(i)) - rank_1(i) + 1$}
\EndFunction
\end{algorithmic}

The group of operations consisting of $lca$, $distance$, $height$ and $deepest\_vertex$ has one thing in common: they all can be solved by solved by range queries.

\begin{algorithmic}
\Function{lca}{$i_1, i_2$}
	\If{$is\_ancestor(i_1, i_2)$}
		\State \Return{$i_1$}
	\ElsIf{$is\_ancestor(i_2, i_1)$}
		\State \Return{$i_2$}
	\Else
		\State \Return{$enclose(i_1, i_2)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{distance}{$i_1, i_2$}
	\State $a \gets lca(i_1, i_2)$
	\State \Return{$depth(i_1) + depth(i_2) - 2 depth(a)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{deepest\_vertex}{$i$}
	\State \Return{$RMQi(i, match(i))$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{height}{$i$}
	\State \Return{$depth(deepest\_vertex(i)) - depth(i)$}
\EndFunction
\end{algorithmic}

\subsubsection{In-Order Rank and Select}

\todo{in-order}

\bigskip

Various indices were proposed to extend the set of supported operations beyond what we have shown.
\todo{Refs: Balanced Parentheses Strike Back}
\begin{itemize}
	\item index support for $child\_rank$ and $child\_select$;
	\item index support for $level\_ancestor$;
	\item index support for querying leaves in a subtree.
	We showed the technique in \ref{ss:leaf-queries} where we were looking for the pattern $0\underline{0}$, whereas for BP it would be $\underline{(})$.
\end{itemize}

\section{DFUDS}

\emph{Depth-First Unary Degree Sequence} is a hybrid encoding with advantages from both LOUDS (child queries are natively supported) and BP (each subtree is stored locally instead of being spread throughout the encoding).
The encoding is defined recursively:
A leaf is encoded as a closing parenthesis.
An inner vertex is encoded as a $degree$ opening parentheses followed by a single closing parenthesis and concatenated encoding of its children.
For convenience, one opening parenthesis is prepended to make the sequence of parentheses balanced.

\todo{formalize queue}

\begin{algorithmic}
\Function{construct}{$R$}
	\State $S \gets \{R\}$ \Comment{The stack is initialized with the root of the tree}
	\State $write("(")$
	\While{$V \gets S$}
%		\If{$V.state = UNSEEN$} \Comment{We came from its parent}
%			\State $V.state \gets OPEN$
%			\State $S \gets \{V\}$ \Comment{We return to $V$ after all its children}
			\ForAll{$C \gets children(V)$}
				\State $write("(")$
			\EndFor
			\State $ S \gets children(V)$
			\State $write(")")$
%		\ElsIf{$V.state = OPEN$} \Comment{All children has been processed}
%			\State $V.state \gets CLOSED$
%		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}

\begin{lemma}
	This encoding gives indeed a balanced string of parentheses.
\end{lemma}
\begin{proof}
	Each subtree lacks one opening parenthesis at the beginning to be correctly matched string of parentheses.
	
	The proof goes by induction.
	The claim holds for a leaf, which is only a closing parenthesis, which misses its matching opening one.
	
	We assume, that the claim holds for all $degree$ subtrees $T_1, \ldots, T_d$ of vertex $v$.
	Vertex $v$ contains $degree$ opening and one closing parenthesis.
	The closing one matches the last opening one, leaving $degree - 1$ of be matched with the excessive ones in the subtrees.
	$T_1, \ldots, T_{d-1}$ gets matched, leaving one closing parenthesis in $T_d$ unmatched, which is the one that the claim requires.
	
	The only unmatched parenthesis is matched in the end with the artificially prepended one.
\end{proof}

\subsection{Basic Navigation Queries}

We associate each vertex with the first symbol of its representation.
Then it is easy to test whether a vertex is a leaf or not.

\begin{algorithmic}
\Function{is\_root}{$i$}
	\State \Return{$i = 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_leaf}{$i$}
	\State \Return{$S[i] = ')'$} \Comment{Is the parenthesis a closing one?}
\EndFunction
\end{algorithmic}

For the following operation, the crucial observations are:
\begin{enumerate}
	\item The opening parentheses in the degree sequence matches the closing parentheses immediately preceding a child representation.
	\item In a subtree of a vertex $v$, the last closing parenthesis, which represents the last leaf, matches a parenthesis in a degree sequence of $v$'s parent.
\end{enumerate}

We first define a helper functions which navigate from any position in vertex representation to its beginning (which is the symbol associated with the vertex) and to its end (which is always a closing parenthesis).

\begin{algorithmic}
\Function{to\_beginning}{$p$}
	\If{$p = 0$}
		\State \Return{$-1$} \Comment{The representation of root starts at position 1}
	\ElsIf{$prev_)(p) < 0$}
		\State \Return{$1$} \Comment{Correction for the root}
	\Else
		\State \Return{$prev_)(p) + 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{to\_end}{$p$}
	\If{$p = 0$}
		\State \Return{$-1$}
	\Else
		\State \Return{$succ_)(p)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{to\_last}{$p$} \Comment{Navigates to the end of the subtree representation}
	\If{$is\_leaf(i)$}
		\State \Return{$p$}
	\Else
		\State \Return{$find\_close(enclose(to\_beginning(p)))$}
	\EndIf
\EndFunction
\end{algorithmic}

Using these function we can support pre-order rank and select queries.
Post-order operations are not supported.

\begin{algorithmic}
\Function{pre\_rank}{$i$}
	\State \Return{$rank_)(to_end(i))$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{pre\_select}{$i$}
	\State \Return{$to\_beginning(select_)(i))$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{parent}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State $p \gets find\_open(i - 1)$ \Comment{Inside parent's degree sequence}
		\State \Return{$to\_beginning(p)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{degree}{$i$}
	\State \Return{$to\_end(i) - i$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_rank}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State $p \gets find\_open(i - 1)$
		\State \Return{$to\_end(p) - p$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_select}{$i, n$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State $p \gets to\_end(i) - n$
		\State \Return{$find\_close(p) + 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\subsection{Other operations}

\begin{algorithmic}
\Function{is\_ancestor}{$i, j$}
	\If{$is\_leaf(i)$}
		\State \Return{$i = j$}
	\Else
		\State \Return{$j \ge i \booland j \le to\_last(i)$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{subtree\_size}{$i$}
	\If{$is\_leaf(i)$}
		\State \Return{$1$}
	\Else
		\State \Return{$rank_)(to\_last(i)) - rank_)(i)$}
	\EndIf
\EndFunction
\end{algorithmic}

\subsubsection{Lowest Common Ancestor}

The operation LCA works similarly as in BP, however it needs to be shown that it works.
Let's assume that neither $i_1$ nor $i_2$ is ancestor of the other one; the $min(i_1, i_2)$ the answer.
We further assume that $i_1 < i_2$ and that the lowest common ancestor is $j = lca(i_1, i_2)$.
The vertex $j$ is left from both $i_1, i_2$ because it is assigned lower pre-order number than any of its descendants.
We again (as in section \ref{ss:enclose2}) call $p_1 < p_2$ the distinct children of $j$ which contain $i_1$ and $i_2$.

We look at excess values of children of $j$.
Each child and its subtree forms a sequence of matching parenthesis with the exception of the last one, which is a closing parenthesis.
From this follows that $rmqi(i, to\_last(i)) = to\_last(i)$.

We look into the properties of $rmqi(i_1, i_2 - 1)$.
Every child, whose ending parenthesis is contained in the range sets a new minimum.
The subtree of $p_2$ could cause a problem, that it would contain the position of the minimum.
It cannot be the last parenthesis of $p_2$, because we end the interval just before it.
It also will not be any other parenthesis $p \ge p_2$ because $excess(p) \ge excess(to_last(p_2)) + 1 = excess(to\_last(child\_prev(p_2)))$.
In case of equality, the $rmqi$ returns the left-most occurrence of the minimum.

The $rmqi(i_1, i_2 - 1)$ returns position of the last parenthesis of the previous sibling of $p_2$ and therefore $p_2 = rmqi(i_1, i_2 - 1) + 1$.
The result is then $lca(i_1, i_2) = j = parent(p_2)$.

\begin{algorithmic}
\Function{lca}{$i_1, i_2$}
	\If{$is\_ancestor(i_1, i_2)$}
		\State \Return{$i_1$}
	\ElsIf{$is\_ancestor(i_2, i_1)$}
		\State \Return{$i_2$}
	\Else
		\State $p_2 \gets rmqi(i_1, i_2 - 1) + 1$
		\State \Return{$parent(p_2)$}
	\EndIf
\EndFunction
\end{algorithmic}

\bigskip

Various indices were proposed to extend the set of supported operations beyond what we have shown.
\todo{Refs: Ultra-succinct representation of ordered trees}
\begin{itemize}
	\item index support for $depth$, which makes possible to query $distance$ between vertices;
	\item index support for $level\_ancestor$;
	\item index support for querying leaves in a subtree.
	This again uses local properties of detecting leaves.
	We would be looking for the second of two consecutive closing parentheses $)\underline{)}$.
	Note that in case when the tree root is a leaf, this does not work, however this special case is easy to handle.
\end{itemize}

\subsection{Comparison of BP and LOUDS}

BP is the easiest way to encode a tree in an array of $2n$ bits.
Its main advantage is the simplicity and once natural support of $depth$ queries, for which it pays by hard $child\_rank$, $child\_select$ and $degree$ operations.

DFUDS is the opposite of BP: it is less intuitive, it supports all the basic navigation queries, however it lacks an easy support for $depth$ queries.

It turns out that $lca$ is supported by both representations in a very similar way, which can be surprising.
There are indices which add support for the operations which are native for the other structure, however they tend to be rather theoretically interesting than useful in practice. \todo{ref}

It is not possible to say that one is better than the other one; it always depends on their usage.
For example, if we restrict degrees of the vertices to be constant, BP representation is suddenly a very good choice.
Similarly, the restriction of height of the tree causes DFUDS to overcome the lack of native $depth$ operation by a brute force implementation.