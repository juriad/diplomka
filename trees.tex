\chapter{Trees}

There are many ways to represent trees in memory.
The traditional approach is to have a structure for each vertex pointing to all its children and its parent, and sometimes storing an additional value.
In our discussion we can assume that no additional value is present; if it was, we could move it to an external table and reference it by a pointer while maintaining the same space complexity.
We are therefore interested in representation only of the structure of the tree.

We can express how many such trees with $n$ vertices exist in total using Catalan numbers.
$$ | \mathcal{T}(n) | = C_{n-1} = \frac{1}{n} {2n - 2 \choose n - 1} $$
The $-1$ stems from the tree having a single root.
$$ \log | \mathcal{T}(n) | \sim \log \frac{1}{n}\frac{4^{n-1}}{\sqrt{\pi (n-1)}} = 2(n-1) - \frac{1}{2} \log{\pi (n - 1)} - \log n \sim 2n - O(\log n) $$
When we design a succinct data structure for ordinal trees, we are limited by the space given by the leading term: $2n + o(n)$ bits.

In the traditional data structures, each edge of the tree is stored twice as a pointer of size $w$.
Even if we did not need any other space to manage the vertex structures, the space occupied by the edges takes $\Omega (n \log n)$.

In this chapter we show several data succinct structures which overcome the logarithmic factor introduced by pointers and get close to the optimum space complexity.

\section{Representations}

A tree can be stored as a bit string in several different ways:
\begin{itemize}
	\item Level-Order Unary Degree Sequence -- a simple heap-like structure which supports the basic navigation queries requiring only rank and select;
	\item Balanced Parentheses -- uses the natural mapping between ordinal trees and matching parentheses;
	\item Depth-First Unary Degree Sequence -- combination of the previous two approaches offering an alternative mapping to matching parentheses;
	\item Fully-Functional -- a data structure built on top of a sequence of matching parentheses, however it uses different primitives then rank and select;
	\item Tree Covering -- recursive decomposition of the tree into smaller trees which are then encoded;
\end{itemize}

We define operations which we discuss in context of various representations of the tree.

\noindent\begin{tabularx}{\textwidth}{|L{0.7}|L{1.3}|}
	\hline
	$op(arg) \rightarrow ret$
	& Description \\ \hline \hline
	
	$*\_rank(i) \rightarrow n$, \newline
	$*\_select(n) \rightarrow j$, \newline
	$*\_prev(i) \rightarrow j$, \newline
	$*\_next(i) \rightarrow j$, \newline
	$*\_first(i) \rightarrow j$, \newline
	$*\_last(i) \rightarrow j$, \newline
	$*\_size() \rightarrow n$
	& These are general operations which we may want to support on various parts of the tree.
	All operations can be expressed using rank, select, and size, however those are not always available. \\ \hline \hline
	
	$global\_*$ operations
	& The rank and select operations come in four flavors based on method of the tree traversal and when the vertex is assigned its number:
	pre-order, in-order, post-order in case of DFS, and level-order in case of BFS. \\ \hline
	
	$child\_*$ operations, \newline
	$parent(i) \rightarrow j$, \newline
	$is\_root(i) \rightarrow b$
	& The operation $child\_select$ needs an additional argument -- the parent vertex.
	The operations $child\_first$, $child\_last$ can be take parent vertex as an argument instead of the sibling.
	We add the operations $parent$ and $is\_root$ to this category to allow basic navigation queries.
	The operation $child\_size$ is usually called $degree$ and takes the parent vertex as an argument.\\ \hline

	$level\_*$ operations, \newline
	$depth(i) \rightarrow l$
	& The level operations can be parametrized in two orthogonal ways:
	the level of the tree which we are interested in (or range thereof), and subtree of the tree we are restricted the queries to. \\ \hline
	
	$leaf\_*$ operations, \newline
	$is\_leaf(i) \rightarrow b$
	& Operations on the set of leaves in the tree.
	The rank should be monotonous in respect to the vertex rank. 
	Again, the queries can be restricted to levels and subtrees.\\ \hline \hline
	
	$is\_ancestor(i, j) \rightarrow b$, \newline
	$level\_ancestor(i, l) \rightarrow j$, \newline
	$lca(i_1, i_2) \rightarrow j$
	$distance(i_1, i_2) \rightarrow n$
	& The operation $lca$ stands for Lowest Common Ancestor.
	Ancestral operations are usually hard to support and require specialized indices. \\ \hline
	
	$height(i) \rightarrow l$, \newline
	$deepest\_vertex(i) \rightarrow j$, \newline
	$subtree\_size(i) \rightarrow n$
	& Other possible operations which could be supported by the data structure. \\ \hline
\end{tabularx}

In the queries we use $i$ and $j$ to refer to the internal representation of the vertex.
Although it often is the same as position of a specific symbol related to the vertex in the representation, for the user of the structure it is an atomic value with no meaning other than a reference which can be used for querying the structure.
If the number of the vertex matters, the user is advised to use one of the ranking operations which map the vertices into an interval $[0, n-1]$.
This can be necessary if we want to interact with other structures, such as addressing the value of the vertex stored in an external table.

\section{LOUDS}

The first method of storing an ordinal tree succinctly was first described by Jacobson in \todo{article}.
The encoding of the tree is based on its vertices reporting their degrees in unary system.
Vertices are processed in by levels; the representation is prefixed by \verb|10|:
\begin{algorithmic}
\Function{construct}{$R$}
	\State $Q \gets \{R\}$ \Comment{The queue is initialized with the root of the tree}
	\State $write("10")$
	\While{$V \gets Q$}
		\ForAll{$C \gets children(V)$}
			\State $write("1")$
			\State $Q \gets \{C\}$
		\EndFor
		\State $write("0")$
	\EndWhile
\EndFunction
\end{algorithmic}

\begin{lemma}
	In a LOUDS representation of a tree with $n$ vertices, there are $n$ ones and $n+1$ zeros.
	Such encoding is succinct.
\end{lemma}
\begin{proof}
	The \verb|10| corresponds to an artifical supervertex which has a single child -- the root of the tree.
	Each vertex of the tree is a child of some vertex and therefore was accounted in the parent's degree.
	For each vertex, there is a one in its parent's representation.
	The number of ones is the same as the number of vertices in the tree.
	Each vertex is responsible for its own zero, plus there is a zero in the supervertex representation.
	
	As there are $2n+1$ bits in total, the representation is succinct.
\end{proof}

As there is a one and a zero belonging to each vertex, we can represent the $i$-th vertex by $i$-th one and $(i+1)$-th zero.
It could be more convenient to represent the supervertex with only \verb|1| instead of \verb|10|.
That way the operations would become clearer and off by one errors would not be an issue.
However we follow the representation as it was originally proposed.

\subsection{Basic Navigational Queries}

In order to support basic navigation queries in this representation, we add rank and select indices to turn it into a FID.
We formulate all the operations in terms of one-based numbering of vertices.
Zero-based implementation are also possible \todo{ref} and it even can compete the other representations.
\todo{Engineering the LOUDS representation}
Because of the correspondence between ones and zeros, we can easily change between them.

\begin{algorithmic}
\Function{to\_ones}{$i$}
	\State \Return{$select_1(rank_0(i) - 1)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{to\_zeros}{$i$}
	\State \Return{$select_0(rank_1(i) + 1)$}
\EndFunction
\end{algorithmic}

The global rank and select operations are one based rank and selects on the underlying bit string.

We know that the one of vertex is within the representation of its parent and the zero ends the list of ones belonging to its children.
Support of the queries is easy:

\begin{algorithmic}
\Function{is\_root}{$i$}
	\State \Return{$i = 0$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_leaf}{$i$}
	\State \Return{$select_0(rank_1(i)) + 1 = 0$} \Comment{Is there the first child?}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{parent}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$select_1(rank_0(i))$} \Comment{Conversion from zeros to ones; off by one}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{degree}{$i$}
	\State $next_0 \gets select_0(rank_1(i) + 1)$ \Comment{The zero within the vertex representation}
	\State $prev_0 \gets select_0(rank_1(i))$ \Comment{The zero within the previous vertex rep.}
	\State \Return{$next_0 - prev_0 - 1$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_select}{$i, k$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\ElsIf{$k \ge degree(i)$}
		\State \Return{$-1$}
	\Else
		\State $first \gets select_0(rank_1(i))$ \Comment{Preceding zero}
		\State \Return{$first + k$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_last}{$i$} \Comment{\textsc{child\_first} is merrily $child\_select(i, 1)$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State $zero \gets select_0(rank_1(i) + 1)$ \Comment{Terminal zero}
		\State \Return{$zero - 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_rank}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State $first \gets select_0(rank_0(i)) + 1$ \Comment{The left-most sibling}
		\State \Return{$i - first$}
	\EndIf
\EndFunction
\end{algorithmic}

\bigskip

We show how we can support more types of queries by augmenting the data structure with sublinear indices.
In our case, we use auxiliary bit strings and on top of them we build the ranking and selecting structures which we already know from FIDs.

\subsection{Depth and Level Queries}

We propose a new index for LOUDS representation which allows to query depth of a vertex and supports all level queries without restriction on subtree.
As far as we know, this index has not been described before.

If we knew where the boundaries of a level are in the bit string, stored also in a bit string, then a simple rank operation would give us the depth.
The problem with storing boundaries of all levels is that there can be up to $O(n)$ levels in total.
We work around the problem by utilizing the fact that if there are many levels, then these levels must be short.
They are in fact short enough for us to precompute the level boundaries in a look-up table.

We define a bit string $D$ which contains $1$ at the position of the terminal zero of the last vertex in a level, including the zero which belongs to the supervertex.
Using $D$ we can support $level\_rank$, $level\_select$ (and thereby all general $level\_*$) and $depth$ operations.

\begin{algorithmic}
\Function{level\_rank}{$i$}
	\State $prev_0 \gets prev_1(D, i)$ \Comment{Terminal zero of the previous level}
	\State \Return{$rank_1(S, i) - rank_1(S, prev_0)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{level\_select}{$i, l$}
	\State $prev_0 \gets select_1(D, l)$ \Comment{Terminal zero of the previous level}
	\State \Return{$select_1(S, rank_1(S, prev_0) + l)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{level\_size}{$l$}
	\State $prev_0 \gets select_1(D, l)$ \Comment{Terminal zero of the previous level}
	\State $next_0 \gets select_1(D, l + 1)$ \Comment{Terminal zero of the next level}
	\State \Return{$rank_1(S,  next_0) - rank_1(S, prev_0)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{depth}{$i$}
	\State \Return{$rank_1(D, i)$}
\EndFunction
\end{algorithmic}

\subsection{Succinct Index for Depth}

How to represent $D$ in $o(n)$ memory in order to keep the structure succinct?
We split this string $D$ into blocks of size $b = \frac{\log 2n}{2}$ and for each block we remember only the position of the first $1$, or lack thereof.
This table $D'$ requires $\frac{2n}{b} \log b = O(\frac{n \log\log n}{\log n}) = o(n)$ bits.

We now show how to restore any $b$ consecutive bits of the original bit string $D$ in constant time.
If there is no $1$ in a block, there is also no level boundary and such block is all zeros.
If there is a $1$ and its position is equal to $2n$, then it is the end of the last level and the block contains only this one $1$.

Otherwise, there is $1$ at position $p$ and there must be a $1$ in the representation of the level, because it is not the last one.
We find this last inner vertex of the layer using predecessor search on $S$ and find position $z$ of its zero; this is the end of the next level.
If $z$ is outside of the block, we end.

The whole level spanning $S[p+1, z]$ is contained within the block.
Now we can use a look-up table which we index by the part of $S$ which belongs to the block $b$ and by offsets of $p$ and $z$.
The look-up table gives us all positions of ends of levels within the block.
Such table merrily captures the repeated computation of finding last inner vertex on a level and turning it into zero-based number.

\begin{algorithmic}
\Function{block\_of\_D}{$i$}
	\State $p' \gets D'[i]$
	\If{$p' = -1$} \Comment{No $1$ in block}
		\State \Return{$0^b$}
	\Else
		\State $p \gets i b + p'$
		\If{$p = 2n$} \Comment{End of the last level}
			\State \Return{$0^b \bitor (1 \bitlsh (b - p' - 1))$} \Comment{$1$ at position $p'$}
		\Else
			\State $z \gets to\_zeros(pred_1(S, p))$
			\If{$z \ge (i+1) b $} \Comment{Level ends outsize block $b$}
				\State \Return{$0^b \bitor (1 \bitlsh (b - p' - 1))$}
			\Else
				\State \Return{$table[S[i b:(i+1)b], p', z - i b]$}
			\EndIf
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}

\subsection{\label{ss:leaf-queries}Leaf Queries}

Tree data structures often allows traversal of leaves in left to right fashion.
This seems to be impossible to support in our LOUDS representation.
Instead, we support enumeration of leaves and access to leaves in BFS order.
Although we defined the operations in sheer generality to be performed on a subtree of the tree, we allow no such restriction here.
When incorporate the depth index, we can parametrize the operations by depth of the leaves -- a pair of minimum and maximum depth: $dp = (min, max): min \le max$; either value can be left unbounded.

\begin{lemma}
	Whenever there are two consecutive zeros in LOUDS representation, the latter one is associated with a leaf.
\end{lemma}
\begin{proof}
	There is always a zero immediately preceding the representation of every vertex.
	A leaf is a vertex with degree equal to zero; LOUDS representation of such vertex is only a single zero.
	A leaf can therefore be localized by looking for two consecutive zeros; this gives us its zero-based number.
\end{proof}

We have seen a solution to a similar problem in \ref{ss:index-without-data}.
Here the formula for the derived bit string is:
$$L = \bitnot S \bitand \bitnot (S \bitrsh 1)$$
As we have already mentioned, we build rank and select indices on top of this calculated bit string $L$.

\begin{algorithmic}
\Function{leaf\_size}{$dp$}
	\State $first \gets level\_first(dp.min)$ \Comment{First vertex matching $dp$}
	\State $first_0 \gets to\_zeros(first)$
	\State $last_0 \gets to\_zeros(level\_last(dp.max))$
	\State \Return $rank_1(L, last_0) - rank_1(L, first_0) + is\_leaf(first)$
\EndFunction
\end{algorithmic}

\begin{algorithmic}	
\Function{leaf\_rank}{$dp, i$}
	\If{$depth(i)\ not\ within \ dp$}
		\State \Return{$-1$}
	\ElsIf{$not\ is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State $first_0 \gets to\_zeros(level\_first(dp.min))$
		\State $rank_1(L, to\_zeros(i)) - rank_1(L, first_0)$
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{leaf\_select}{$dp, n$}
	\If{$n \ge leaf\_size(dp)$}
		\State \Return{$-1$}
	\Else
		\State $first_0 \gets to\_zeros(level\_first(dp.min))$
		\State $offset \gets rank_1(L, first_0)$
		\State \Return{$to\_ones(select_1(L, n + offset))$}
	\EndIf
\EndFunction
\end{algorithmic}

\bigskip

The main problem of this representation appears to lay in non-locality of the data.
We often want to work in limited subtrees, which in this representation are spread throughout the bit string.
On he other hand its easy implementation requiring only two types of indices make it suitable for cases when we don't pose many requirements on the supported operations.

\section{BP}

In the previous section, we have seen that it is possible to build a succinct data structure for storing trees which requires only rank and select queries from the underlying bit string.
Here we focus on a different schema which exploits the property that the two symbols associated with a vertex are correctly matched in the bit string, for which we utilize the match and enclose operations which we developed earlier in \ref{s:op-bp}.

The representation is based on Depth-First Search and follows two rules:
\begin{enumerate}
	\item When we enter a vertex from its parent, we \emph{open} it, which is denoted in the representation by an opening parenthesis.
	\item When we leave a vertex to its parent, we \emph{close} it, which is denoted by a closing parenthesis.
\end{enumerate}
Although the root vertex does not have a parent, we open and close it as if it had one.

\begin{algorithmic}
\Function{construct}{$R$}
	\State $S \gets \{R\}$ \Comment{The stack is initialized with the root of the tree}
	\While{$V \gets S$}
		\If{$V.state = UNSEEN$} \Comment{We came from its parent}
			\State $ S \gets \{V\}$ \Comment{We return to $V$ after all its children}
			\State $V.state \gets OPEN$
			\State $write("1")$
			\State $ S \gets children(V)$
		\ElsIf{$V.state = OPEN$} \Comment{All children has been processed}
			\State $V.state \gets CLOSED$
			\State $write("0")$
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}

An alternative definition of this schema can be expressed recursively:
\begin{enumerate}
	\item A leaf is encoded with a pair of parentheses.
	\item An inner vertex is encoded as a concatenated list of encodings of its children enclosed by a pair of parentheses.
\end{enumerate}
From this definition, we can see that each subtree occupies a continuous substring.

\bigskip

We associate each vertex with its opening parenthesis; because of the symmetry in comparison to LOUDS representation, there is no reason to choose opening or closing parentheses over the others.
By using the operation $match$ we can easily switch between these two.

We can immediately support pre-order and post-order global ranks and selects as one-based and zero-based ranks and selects on the underlying bit string $S$.
We show implementation of the operations which do not need any auxiliary index and can be expressed using only the primitives provided by $S$.

\todo{Use \textbackslash{}mathit pretty much everywhere}

\begin{algorithmic}
\Function{is\_root}{$i$}
	\State \Return{$i = 0$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_leaf}{$i$}
	\State \Return{$S[i+1] = ')'$} \Comment{Is the parenthesis immediately closed?}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{parent}{$i$}
	\If{$is\_root(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$enclose(i)$}
	\EndIf
\EndFunction
\end{algorithmic}

Neither $degree$ nor $child\_rank$ nor $child\_select$ is possible; we therefore resort to implementation of the rest of the $child\_*$ operations:

\begin{algorithmic}
\Function{child\_first}{$i$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$i+1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_last}{$i$}
	\If{$is\_leaf(i)$}
		\State \Return{$-1$}
	\Else
		\State \Return{$find\_close(i) - 1$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_next}{$i$}
	\State {$n = find\_close(i) + 1$}
	\If{$S[n] = ')'$}
		\State \Return{$-1$}
	\Else
		\State \Return{$n$}
	\EndIf
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{child\_prev}{$i$}
	\If{$S[i - 1] = '('$}
		\State \Return{$-1$}
	\Else
		\State \Return{$find\_open(i - 1)$}
	\EndIf
\EndFunction
\end{algorithmic}

The other supported operations are:
\begin{algorithmic}
\Function{depth}{$i$}
	\State \Return{$paren\_depth(i)$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{is\_ancestor}{$i, j$}
	\State \Return{$i \le j \booland find\_close(i) \ge j$}
\EndFunction
\end{algorithmic}

\begin{algorithmic}
\Function{subtree\_size}{$i$}
	\State \Return{$rank_1(find\_close(i)) - rank_1(i) + 1$}
\EndFunction
\end{algorithmic}

\bigskip

Various indices were proposed to extend the set of supported operations.
\todo{Refs: Balanced Parentheses Strike Back}
\begin{itemize}
	\item index support for $child\_rank$ and $child\_select$;
	\item index support for $lca$, $distance$ and $height$, ($deepest\_vertex$, \todo{maybe, check});
	\item index support for $level\_ancestor$;
	\item index support for querying unrestricted leaves.
	We showed the technique in \ref{ss:leaf-queries} where we were looking for the pattern $0\mathbf{0}$, whereas here it would be $\textbf{(})$.
\end{itemize}

\section{DFUDS}

Depth-First Unary Degree Sequence is defined recursively:
A leaf is encoded as a closing parenthesis.
An inner vertex is encoded as a $degree-1$ opening parentheses followed by a single closing parenthesis and concatenating encoding of the children.
For convenience, one opening parenthesis is prepended to make the sequence of parentheses balanced.

\begin{lemma}
This encoding gives indeed a balanced string of parentheses.
\end{lemma}
\begin{proof}
\todo{proof}
\end{proof}
